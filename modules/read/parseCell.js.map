{"version":3,"file":"parseCell.js","names":["parseCellValue","parseCellCoordinates","getCellValue","getCellInlineStringValue","getOuterXml","parseCell","node","sheet","xml","values","styles","properties","options","coords","getAttribute","valueElement","value","textContent","type","hasAttribute","row","column","getInlineStringValue","getInlineStringXml","getStyleId"],"sources":["../../source/read/parseCell.js"],"sourcesContent":["import parseCellValue from './parseCellValue.js'\n\nimport {\n  parseCellCoordinates\n} from './coordinates.js'\n\nimport {\n  getCellValue,\n  getCellInlineStringValue\n} from '../xml/xlsx.js'\n\nimport {\n  getOuterXml\n} from '../xml/dom.js'\n\n// Example of a `<c/>`ell element:\n//\n// <c>\n//    <f>string</f> — formula.\n//    <v>string</v> — formula pre-computed value.\n//    <is>\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\n//       <r>\n//          <rPr>\n//            ...\n//          </rPr>\n//          <t>string</t>\n//       </r>\n//       <rPh sb=\"1\" eb=\"1\">\n//          <t>string</t>\n//       </rPh>\n//       <phoneticPr fontId=\"1\"/>\n//    </is>\n//    <extLst>\n//       <ext>\n//          <!--any element-->\n//       </ext>\n//    </extLst>\n// </c>\n//\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\n  const coords = parseCellCoordinates(node.getAttribute('r'))\n\n  const valueElement = getCellValue(sheet, node)\n\n  // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\n  let value = valueElement && valueElement.textContent\n\n  let type\n  if (node.hasAttribute('t')) {\n    type = node.getAttribute('t')\n  }\n\n  return {\n    row: coords[0],\n    column: coords[1],\n    value: parseCellValue(value, type, {\n      getInlineStringValue: () => getCellInlineStringValue(sheet, node),\n      getInlineStringXml: () => getOuterXml(node),\n      getStyleId: () => node.getAttribute('s'),\n      styles,\n      values,\n      properties,\n      options\n    })\n  }\n}"],"mappings":"AAAA,OAAOA,cAAc,MAAM,qBAAqB;AAEhD,SACEC,oBAAoB,QACf,kBAAkB;AAEzB,SACEC,YAAY,EACZC,wBAAwB,QACnB,gBAAgB;AAEvB,SACEC,WAAW,QACN,eAAe;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,SAAS,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;EACvF,IAAMC,MAAM,GAAGZ,oBAAoB,CAACK,IAAI,CAACQ,YAAY,CAAC,GAAG,CAAC,CAAC;EAE3D,IAAMC,YAAY,GAAGb,YAAY,CAACK,KAAK,EAAED,IAAI,CAAC;;EAE9C;EACA;EACA;EACA,IAAIU,KAAK,GAAGD,YAAY,IAAIA,YAAY,CAACE,WAAW;EAEpD,IAAIC,IAAI;EACR,IAAIZ,IAAI,CAACa,YAAY,CAAC,GAAG,CAAC,EAAE;IAC1BD,IAAI,GAAGZ,IAAI,CAACQ,YAAY,CAAC,GAAG,CAAC;EAC/B;EAEA,OAAO;IACLM,GAAG,EAAEP,MAAM,CAAC,CAAC,CAAC;IACdQ,MAAM,EAAER,MAAM,CAAC,CAAC,CAAC;IACjBG,KAAK,EAAEhB,cAAc,CAACgB,KAAK,EAAEE,IAAI,EAAE;MACjCI,oBAAoB,EAAE;QAAA,OAAMnB,wBAAwB,CAACI,KAAK,EAAED,IAAI,CAAC;MAAA;MACjEiB,kBAAkB,EAAE;QAAA,OAAMnB,WAAW,CAACE,IAAI,CAAC;MAAA;MAC3CkB,UAAU,EAAE;QAAA,OAAMlB,IAAI,CAACQ,YAAY,CAAC,GAAG,CAAC;MAAA;MACxCJ,MAAM,EAANA,MAAM;MACND,MAAM,EAANA,MAAM;MACNE,UAAU,EAAVA,UAAU;MACVC,OAAO,EAAPA;IACF,CAAC;EACH,CAAC;AACH"}