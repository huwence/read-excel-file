{"version":3,"file":"convertToJson.js","names":["parseDate","Integer","isInteger","URL","isURL","Email","isEmail","DEFAULT_OPTIONS","isColumnOriented","data","schema","options","rowMap","ignoreEmptyRows","validateSchema","transpose","columns","results","errors","i","length","result","read","push","error","row","rows","rowIndex","object","isEmptyObject","key","schemaEntry","isNestedSchema","type","Array","isArray","rawValue","indexOf","undefined","value","reason","notEmpty","array","parseArray","map","_value","parseValue","required","column","includeNullValues","prop","Object","keys","parse","parseCustomValue","parseValueOfType","oneOf","validate","message","String","isNaN","isFinite","Number","stringifiedValue","Date","valueOf","date","properties","Boolean","Error","name","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_","entry"],"sources":["../../../source/read/schema/convertToJson.js"],"sourcesContent":["import parseDate from '../parseDate.js'\n\nimport Integer, { isInteger } from '../../types/Integer.js'\nimport URL, { isURL } from '../../types/URL.js'\nimport Email, { isEmail } from '../../types/Email.js'\n\nconst DEFAULT_OPTIONS = {\n  isColumnOriented: false\n}\n\n/**\n * Convert 2D array to nested objects.\n * If row oriented data, row 0 is dotted key names.\n * Column oriented data is transposed.\n * @param {any[][]} data - An array of rows, each row being an array of cells.\n * @param {object} schema\n * @return {object[]}\n */\nexport default function(data, schema, options) {\n  if (options) {\n    options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    }\n  } else {\n    options = DEFAULT_OPTIONS\n  }\n\n  const {\n    isColumnOriented,\n    rowMap,\n    ignoreEmptyRows\n  } = options\n\n  validateSchema(schema)\n\n  if (isColumnOriented) {\n    data = transpose(data)\n  }\n\n  const columns = data[0]\n\n  const results = []\n  const errors = []\n\n  for (let i = 1; i < data.length; i++) {\n    const result = read(schema, data[i], i, columns, errors, options)\n    if (result !== null || ignoreEmptyRows === false) {\n      results.push(result)\n    }\n  }\n\n  // Correct error rows.\n  if (rowMap) {\n    for (const error of errors) {\n      // Convert the `row` index in `data` to the\n      // actual `row` index in the spreadsheet.\n      // `- 1` converts row number to row index.\n      // `+ 1` converts row index to row number.\n      error.row = rowMap[error.row - 1] + 1\n    }\n  }\n\n  return {\n    rows: results,\n    errors\n  }\n}\n\nfunction read(schema, row, rowIndex, columns, errors, options) {\n  const object = {}\n  let isEmptyObject = true\n  for (const key of Object.keys(schema)) {\n    const schemaEntry = schema[key]\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\n    let rawValue = row[columns.indexOf(key)]\n    if (rawValue === undefined) {\n      rawValue = null\n    }\n    let value\n    let error\n    let reason\n    if (isNestedSchema) {\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\n    } else {\n      if (rawValue === null) {\n        value = null\n      }\n      else if (Array.isArray(schemaEntry.type)) {\n        let notEmpty = false\n        const array = parseArray(rawValue).map((_value) => {\n          const result = parseValue(_value, schemaEntry, options)\n          if (result.error) {\n            value = _value\n            error = result.error\n            reason = result.reason\n          }\n          if (result.value !== null) {\n            notEmpty = true\n          }\n          return result.value\n        })\n        if (!error) {\n          value = notEmpty ? array : null\n        }\n      } else {\n        const result = parseValue(rawValue, schemaEntry, options)\n        error = result.error\n        reason = result.reason\n        value = error ? rawValue : result.value\n      }\n    }\n    if (!error && value === null && schemaEntry.required) {\n      error = 'required'\n    }\n    if (error) {\n      error = {\n        error,\n        row: rowIndex + 1,\n        column: key,\n        value\n      }\n      if (reason) {\n        error.reason = reason\n      }\n      if (schemaEntry.type) {\n        error.type = schemaEntry.type\n      }\n      errors.push(error)\n    } else {\n      if (isEmptyObject && value !== null) {\n        isEmptyObject = false\n      }\n      if (value !== null || options.includeNullValues) {\n        object[schemaEntry.prop] = value\n      }\n    }\n  }\n  if (isEmptyObject) {\n    return null\n  }\n  return object\n}\n\n/**\n * Converts textual value to a javascript typed value.\n * @param  {any} value\n * @param  {object} schemaEntry\n * @return {{ value: any, error: string }}\n */\nexport function parseValue(value, schemaEntry, options) {\n  if (value === null) {\n    return { value: null }\n  }\n  let result\n  if (schemaEntry.parse) {\n    result = parseCustomValue(value, schemaEntry.parse)\n  } else if (schemaEntry.type) {\n    result = parseValueOfType(\n      value,\n      // Supports parsing array types.\n      // See `parseArray()` function for more details.\n      // Example `type`: String[]\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\n      options\n    )\n  } else {\n    result = { value: value }\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\n  }\n  // If errored then return the error.\n  if (result.error) {\n    return result\n  }\n  if (result.value !== null) {\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\n      return { error: 'invalid', reason: 'unknown' }\n    }\n    if (schemaEntry.validate) {\n      try {\n        schemaEntry.validate(result.value)\n      } catch (error) {\n        return { error: error.message }\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Converts textual value to a custom value using supplied `.parse()`.\n * @param  {any} value\n * @param  {function} parse\n * @return {{ value: any, error: string }}\n */\nfunction parseCustomValue(value, parse) {\n  try {\n    value = parse(value)\n    if (value === undefined) {\n      return { value: null }\n    }\n    return { value }\n  } catch (error) {\n    return { error: error.message }\n  }\n}\n\n/**\n * Converts textual value to a javascript typed value.\n * @param  {any} value\n * @param  {} type\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\n */\nfunction parseValueOfType(value, type, options) {\n  switch (type) {\n    case String:\n      if (typeof value === 'string') {\n        return { value }\n      }\n      // Excel tends to perform a forced automatic convertion of string-type values\n      // to number-type ones when the user has input them. Otherwise, users wouldn't\n      // be able to perform formula calculations on those cell values because users\n      // won't bother manually choosing a \"numeric\" cell type for each cell, and\n      // even if they did, choosing a \"numeric\" cell type every time wouldn't be an\n      // acceptable \"user experience\".\n      //\n      // So, if a cell value is supposed to be a string and Excel has automatically\n      // converted it to a number, perform a backwards conversion.\n      //\n      if (typeof value === 'number') {\n        if (isNaN(value)) {\n          return { error: 'invalid', reason: 'invalid_number' }\n        }\n        // The global `isFinite()` function filters out:\n        // * NaN\n        // * -Infinity\n        // * Infinity\n        //\n        // All other values pass (including non-numbers).\n        //\n        if (!isFinite(value)) {\n          return { error: 'invalid', reason: 'out_of_bounds' }\n        }\n        return { value: String(value) }\n      }\n      return { error: 'invalid', reason: 'not_a_string' }\n\n    case Number:\n    case Integer:\n      // An XLSX file editing software might not always correctly\n      // detect numeric values in string-type cells. Users won't bother\n      // manually selecting a cell type, so the editing software has to guess\n      // based on the user's input. One can assume that such auto-detection\n      // might not always work.\n      //\n      // So, if a cell is supposed to be a numeric one, convert a string value to a number.\n      //\n      if (typeof value === 'string') {\n        const stringifiedValue = value\n        value = Number(value)\n        if (String(value) !== stringifiedValue) {\n          return { error: 'invalid', reason: 'not_a_number' }\n        }\n      }\n      if (typeof value !== 'number') {\n        return { error: 'invalid', reason: 'not_a_number' }\n      }\n      if (isNaN(value)) {\n        return { error: 'invalid', reason: 'invalid_number' }\n      }\n      // At this point, `value` can only be a number.\n      //\n      // The global `isFinite()` function filters out:\n      // * NaN\n      // * -Infinity\n      // * Infinity\n      //\n      // All other values pass (including non-numbers).\n      //\n      if (!isFinite(value)) {\n        return { error: 'invalid', reason: 'out_of_bounds' }\n      }\n      if (type === Integer && !isInteger(value)) {\n        return { error: 'invalid', reason: 'not_an_integer' }\n      }\n      return { value }\n\n    case URL:\n      if (typeof value === 'string') {\n        if (isURL(value)) {\n          return { value }\n        }\n        return { error: 'invalid', reason: 'not_a_url' }\n      }\n      return { error: 'invalid', reason: 'not_a_string' }\n\n    case Email:\n      if (typeof value === 'string') {\n        if (isEmail(value)) {\n          return { value }\n        }\n        return { error: 'invalid', reason: 'not_an_email' }\n      }\n      return { error: 'invalid', reason: 'not_a_string' }\n\n    case Date:\n      // XLSX has no specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n      if (value instanceof Date) {\n        if (isNaN(value.valueOf())) {\n          return { error: 'invalid', reason: 'out_of_bounds' }\n        }\n        return { value }\n      }\n      if (typeof value === 'number') {\n        if (isNaN(value)) {\n          return { error: 'invalid', reason: 'invalid_number' }\n        }\n        if (!isFinite(value)) {\n          return { error: 'invalid', reason: 'out_of_bounds' }\n        }\n        const date = parseDate(value, options.properties)\n        if (isNaN(date.valueOf())) {\n          return { error: 'invalid', reason: 'out_of_bounds' }\n        }\n        return { value: date }\n      }\n      return { error: 'invalid', reason: 'not_a_date' }\n\n    case Boolean:\n      if (typeof value === 'boolean') {\n        return { value }\n      }\n      return { error: 'invalid', reason: 'not_a_boolean' }\n\n    default:\n      if (typeof type === 'function') {\n        return parseCustomValue(value, type)\n      }\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\n  }\n}\n\nexport function getBlock(string, endCharacter, startIndex) {\n  let i = 0\n  let substring = ''\n  let character\n  while (startIndex + i < string.length) {\n    const character = string[startIndex + i]\n    if (character === endCharacter) {\n      return [substring, i]\n    }\n    else if (character === '\"') {\n      const block = getBlock(string, '\"', startIndex + i + 1)\n      substring += block[0]\n      i += '\"'.length + block[1] + '\"'.length\n    }\n    else {\n      substring += character\n      i++\n    }\n  }\n  return [substring, i]\n}\n\n/**\n * Parses a string of comma-separated substrings into an array of substrings.\n * (the `export` is just for tests)\n * @param  {string} string — A string of comma-separated substrings.\n * @return {string[]} An array of substrings.\n */\nexport function parseArray(string) {\n  const blocks = []\n  let index = 0\n  while (index < string.length) {\n    const [substring, length] = getBlock(string, ',', index)\n    index += length + ','.length\n    blocks.push(substring.trim())\n  }\n  return blocks\n}\n\n// Transpose a 2D array.\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\n\nfunction validateSchema(schema) {\n  for (const key of Object.keys(schema)) {\n    const entry = schema[key]\n    if (!entry.prop) {\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\n    }\n  }\n}"],"mappings":"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"}